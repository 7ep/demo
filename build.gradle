buildscript {
  repositories {
    maven {
      url "https://plugins.gradle.org/m2/"
    }
  }
  dependencies {
    classpath "com.github.spacialcircumstances:gradle-cucumber-reporting:0.1.8"
  }
}

plugins {
    id 'war'

    // provides access to a database versioning tool.
    id "org.flywaydb.flyway" version "6.0.8"

    // gretty is a gradle plugin to make it easy to run a server and hotswap code at runtime.
    id 'org.gretty' version '2.3.1'

    // scans our code for static analysis
    id "org.sonarqube" version "2.8"

    // provides unit test coverage
    id 'jacoco'

    // provides the ability to see a tree of dependent tasks
    // for any particular task.
    // usage: gradle <task 1>...<task N> taskTree
    // see https://github.com/dorongold/gradle-task-tree
    id "com.dorongold.task-tree" version "1.3.1"

    // pitest provides mutation testing coverage - this shows
    // which code-under-test is actually "tested", rather than
    // simply being run during the test.  It does this by
    // changing the code and seeing if the test fails as a result.
    id 'info.solidsoft.pitest' version '1.4.0'

    // Dependency Check analyzes the dependencies for 
    // potential security issues.
    // see https://plugins.gradle.org/plugin/org.owasp.dependencycheck
    id "org.owasp.dependencycheck" version "5.2.2"
}

// apply our fancy cucumber reporting program, see https://plugins.gradle.org/plugin/com.github.spacialcircumstances.gradle-cucumber-reporting
apply plugin: "com.github.spacialcircumstances.gradle-cucumber-reporting"

// including our script plugin for running our integration tests
apply from: "$rootDir/gradle/fast_integration_test.gradle"

// including our script plugin for running BDD-type tests
apply from: "$rootDir/gradle/bdd_test.gradle"

// including our script plugin for running Selenified
apply from: "$rootDir/gradle/selenified_tests.gradle"

tasks.withType(JavaCompile) {
    options.compilerArgs << "-Xlint:unchecked"
}

repositories {
    jcenter()
    mavenCentral()
}

configurations {
    localDeps
}

dependencies {
    providedCompile 'javax.servlet:javax.servlet-api:4.0.1'

    // junit, for running unit tests
    testCompile 'junit:junit:4.12'

    // mockito, for mocking objects in our unit tests
    testCompile 'org.mockito:mockito-core:2.28.2'

    // nbvcxz is a tool to determine how robust a password is.  See
    // https://github.com/GoSimpleLLC/nbvcxz
    compile group: 'me.gosimple', name: 'nbvcxz', version: '1.4.3'

    // the glorious equalsverifier.  This is a tool that tests the contract
    // for equals and hashcode are met.  It's very strict.  Because it's very
    // strict, it forces us to create very safe, very solid code.
    // https://mvnrepository.com/artifact/nl.jqno.equalsverifier/equalsverifier
    testCompile group: 'nl.jqno.equalsverifier', name: 'equalsverifier', version: '3.0.3'

    // The commons-lang3 package has some utility classes that are very helpful
    // for those interested in safer coding.  Particularly, the equalsbuilder and hashcodebuilder.
    // https://mvnrepository.com/artifact/org.apache.commons/commons-lang3
    compile group: 'org.apache.commons', name: 'commons-lang3', version: '3.9'

    // a logging framework, so it becomes easily possible to see what is happening
    // in our code in realtime.
    compile group: 'org.apache.logging.log4j', name: 'log4j-api', version: '2.12.1'
    compile group: 'org.apache.logging.log4j', name: 'log4j-core', version: '2.12.1'

    // The following gives us the ability to use slf4j api calls.
    // https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-slf4j-impl
    compile group: 'org.apache.logging.log4j', name: 'log4j-slf4j-impl', version: '2.12.1'


    // we'll use this as our database
    // https://mvnrepository.com/artifact/com.h2database/h2
    localDeps group: 'com.h2database', name: 'h2', version: '1.4.200'

    // so we can put a copy of h2 in a convenient place
    compile configurations.localDeps

    // so we can programmatically run flyway at startup
    compile "org.flywaydb:flyway-core:6.0.8"

    compile 'org.apache.struts:struts2-apps:2.5.20'

}

task copyToLib(type: Copy) {
    from configurations.localDeps
    into "$buildDir/lib"
}

pitest {
    targetClasses = ['com.coveros.training.*']  //by default "${project.group}.*"
    threads = 4
    outputFormats = ['XML', 'HTML']
    timestampedReports = false
}

tasks.getByName('pitest').finalizedBy 'printReportPathsPitest'

task('printReportPathsPitest') {
    doLast {
        print "\n\n\n"
        println "------------------------------------------------------------"
        println "Reports were generated by the tests."
        println "------------------------------------------------------------"
        println ""
        println "PiTest:   build/reports/pitest/index.html"
        println "------------------------------------------------------------"
        print "\n"
    }
}

// configure jetty to run on port 8080 when we run "./gradlew appRun"
gretty {
    httpPort = 8080
    servletContainer = 'tomcat8'
    contextPath = "demo"
    jvmArgs = ['-Dcom.sun.management.jmxremote', '-Dcom.sun.management.jmxremote.port=9999', '-Dcom.sun.management.jmxremote.ssl=false', '-Dcom.sun.management.jmxremote.authenticate=false']
}

// configuration for the cucumber reports.
cucumberReports {
    outputDir = file('build/reports/bdd')
    buildId = '0'
    reports = files('build/bdd/file.json', 'build/bdd/behave_cucumber_style.json')
    testTasksFinalizedByReport = false
}

flyway {
    url = 'jdbc:h2:./build/db/training;AUTO_SERVER=TRUE;MODE=POSTGRESQL'
    driver = 'org.h2.Driver'
    user = ""
    password = ""
    schemas = ['ADMINISTRATIVE', 'LIBRARY', 'AUTH']
}


// starts the h2 console
task startH2Console(type: Exec) {
    dependsOn 'copyToLib'
    commandLine 'javaw', '-cp', 'build/lib/h2-1.4.197.jar', 'org.h2.tools.Console'
}

generateCucumberReports.dependsOn(cucumber)

jacocoTestReport {
    executionData("$buildDir/jacoco/combineCoverage.exec")
}

// a way to combine the coverage reports for the purpose of seeing the
// whole picture when we run jacocoTestReport
task combineCoverage(type: JacocoMerge) {
    executionData = files("$buildDir/jacoco/test.exec", "$buildDir/jacoco/fastIntegrationTest.exec")
    mustRunAfter fastIntegrationTest
}

task testReport(type: GradleBuild) {
    tasks = ['test', 'fastIntegrationTest', 'combineCoverage', 'jacocoTestReport']
}

// Add the combined report when we run check
check.dependsOn(combineCoverage)
check.dependsOn(jacocoTestReport)


sonarqube {
    properties {
        property "sonar.projectKey", "demo"
        property "sonar.projectName", "demo"
        property "sonar.projectDescription", "A demonstration of a web application with good test coverage and best practices"
        property "sonar.sources", "src/main/java"
        property "sonar.tests", "src/test/java,src/integration_test/java,src/bdd_test/java"
        property "sonar.java.binaries", "build/classes/java/main"
        property "sonar.junit.reportPaths", "build/test-results/test/,build/test-results/fastIntegrationTest"
        property "sonar.jacoco.reportPaths", "build/jacoco/test.exec,build/jacoco/fastIntegrationTest.exec"
	property "sonar.host.url", "http://localhost:9000/sonar"
	property "sonar.projectKey", "demo"
	property "sonar.projectName", "Demo Application"
	property "sonar.dependencyCheck.reportPath", "$project.buildDir/reports/dependency-check-report.xml"
        property "sonar.scm.provider", "git"
        property "sonar.scm.forceReloadAll", "true"
        property "sonar.exclusions", "src/main/java/com/coveros/training/autoinsurance/AutoInsuranceScriptServer.java"
    }
}

// parallellize the tests, making them finish sooner.
tasks.withType(Test) {
    maxParallelForks = Runtime.runtime.availableProcessors().intdiv(2) ?: 1
}

task runApiTests(type: Exec) {
    doFirst {
        checkIfAlive();
    }
    workingDir 'api_tests'
    commandLine 'pipenv', 'run', 'pytest', '--junitxml', '../build/test-results/api_tests/TEST-api_test_results.xml'
}

static boolean SearchDirectoryForChromedriver(File dir) {
    return dir.listFiles({ file -> file.name.contains("chromedriver") } as FileFilter).any();
}

static boolean ScanPathForChromeDriver() {
    // Add all the directories from the system PATH variable
    List pathDirectories = System.getenv('PATH').split("[;|:]").toList()

    // Add the local ui_tests directory too - it will still work if it's there
    pathDirectories.add("ui_tests")

    return pathDirectories.any({ dir -> SearchDirectoryForChromedriver(new File(dir)) })
}

// returns true if the application is running.
static void checkIfAlive() {
    int code;
    try {
        URL url = new URL("http://localhost:8080/demo");
        HttpURLConnection connection = (HttpURLConnection) url.openConnection();
        connection.setRequestMethod("GET");
        connection.connect();

        code = connection.getResponseCode();
    } catch (Exception ex) {
        String errorMsg = "\n\n\n" +
                "****************************************\n" +
                "*       SERVER IS NOT RUNNING          *\n" +
                "****************************************\n" +
                " The server has to be running to run    \n" +
                " tests you requested                    \n" +
                "                                        \n" +
                " To start the app:                      \n" +
                "    gradlew appRun                      \n" +
                "****************************************\n";
        throw new Exception(errorMsg);
    }
    if (code != 200) {
        throw new Exception("\n\nServer is not returning a 200.  Instead, it is: " +code + "\n\n");
    }
}

task runBehaveTests(type: Exec) {
    doFirst {
        checkIfAlive();
        def chromedriver_exists_in_ui_tests = ScanPathForChromeDriver();
		def chrm = project.properties['chromedriver.path']

		// make sure that the path to chromedriver isn't null or empty:
		def chromedriver_full_path_empty = chrm == null || chrm.isEmpty()
        if (chromedriver_full_path_empty) {
            chrm = "(NOT SET)"
        }

        if (!chromedriver_exists_in_ui_tests && chromedriver_full_path_empty) {
            ignoreExitValue true
            throw new Exception(


					"\n\n*****************************************************\n" +
					"*****************************************************\n" +
					"Does not look like you have Chromedriver on your \n" +
					"PATH or have set the full directory in gradle.properties.\n\n" +

					"Download it from http://chromedriver.chromium.org/\n" +
					"*****************************************************\n" +
					"*****************************************************\n" +


					"\n\nMore detail:\n  We couldn't find Chromedriver, which is needed to run the \n" +
					"  Behave tests (The UI-focused Behavior Driven Development test)\n" +

					"\nThe easiest way to fix this, once you have downloaded Chromedriver, \n" +
					"is to move the Chromedriver executable into a directory that is in \n" +
					"your path.\n" +

                    "\nFor your reference, here are all the directories we checked:\n\n" +
					System.getenv('PATH') +
					
					"\n\nAn alternate way is to set the path to the Chromedriver executable\n" +
					"in the gradle.properties file, at chromedriver.path\n" +
					
					"\nFor example: \n" +
					"\nchromedriver.path=C:/foo/bar/chromedriver_win32/chromedriver.exe\n" +
                    "\n\nHere is the value of your \"chromedriver.path\" \n(found in gradle.properties): \n\n" +
					chrm +

                    "\n\nIMPORTANT MESSAGES ABOVE! SCROLL UP."

            )
        }
    }
    workingDir 'ui_tests'
    // run behave and output a json file (we'll convert that to Cucumber format later for reporting)
    commandLine 'pipenv', 'run', 'behave', '--format','json','-o','../build/bdd/behave.json', '-D', 'chromedriver_path='+(project.properties['chromedriver.path'] ?: "")

}

// Run a command to convert the Behave json to Cucumber format.
// Once this is done, we can run generateCucumberReport again and it will have the Behave results included.
task convertBehaveOutputToCucumber(type: Exec) {
    commandLine 'pipenv', 'run', 'python', '-m', 'behave2cucumber', '-i', 'build/bdd/behave.json', '-o', 'build/bdd/behave_cucumber_style.json'
}
runBehaveTests.finalizedBy convertBehaveOutputToCucumber


task runAllTests(type: GradleBuild) {
    doFirst {
        checkIfAlive()
    }
    tasks = ['check', 'runApiTests', 'runBehaveTests']
}
// more info on test logging: https://discuss.gradle.org/t/whats-upcoming-in-gradle-1-1-test-logging/7741
test {
    testLogging {
        exceptionFormat "full" // default is "short"
        // uncomment the following to see the unit test progress in the output
        //events "started", "passed", "skipped", "failed", "standardOut", "standardError"
        events "passed", "skipped", "failed", "standardOut", "standardError"

        // set to false to disable detailed failure logs
        showExceptions true

        // enable to see standard out and error streams inline with the test results
        showStandardStreams true
    }

    // Fail the 'test' task on the first test failure
    failFast = true


}

dependencyCheck {
    showSummary = false
    autoUpdate = true
    cveValidForHours = 168 // a week.
    format = 'ALL' // options are  (HTML, XML, CSV, JSON, VULN, ALL).
    failBuildOnCVSS = 9 // see https://www.first.org/cvss/specification-document#5-Qualitative-Severity-Rating-Scale
    suppressionFile = "suppression.xml"
}

task('printReportPathsCheck') {
    doLast {
        print "\n\n\n"
        println "------------------------------------------------------------"
        println "Reports were generated by the tests."
        println "------------------------------------------------------------"
        println ""
        println "Coverage:   build/reports/jacoco/test/html/index.html"
        println "BDD Report: build/reports/bdd/cucumber-html-report-basic/index.html"
        println "Unit Tests: build/reports/tests/"
        println "------------------------------------------------------------"
        print "\n"
    }
}

task('coveros') {
    doLast {
      String fileContents = new File('docs/coveros_text.txt').text
      print fileContents
    }
}

check.finalizedBy 'printReportPathsCheck'

task('printReportPathsDependencyCheck') {
    doLast {
        print "\n\n\n"
        println "---------------------------------------------------------------"
        println "Reports were generated by the tests."
        println "---------------------------------------------------------------"
        println ""
        println "Dependency Check: build/reports/dependency-check-report.html"
        println "---------------------------------------------------------------"
        print "\n"
    }
}

dependencyCheckAnalyze.finalizedBy 'printReportPathsDependencyCheck'

/**
 * this starts the desktop UI for the auto insurance processor
 *  and its accompanying automation script server
 */
task startui(type:JavaExec) {
    classpath = sourceSets.main.runtimeClasspath
    main = 'com.coveros.training.autoinsurance.AutoInsuranceUI'
}

/**
 * This starts the client that controls the automation script
 * server that can control the UI for the auto insurance processor
 */
task startscriptclient(type:JavaExec) {
    classpath = sourceSets.main.runtimeClasspath
    standardInput = System.in
    main = 'com.coveros.training.autoinsurance.AutoInsuranceScriptClient'
}



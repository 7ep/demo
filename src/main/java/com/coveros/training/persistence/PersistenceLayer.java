package com.coveros.training.persistence;

import com.coveros.training.CheckUtils;
import com.coveros.training.StringUtils;
import com.coveros.training.domainobjects.Book;
import com.coveros.training.domainobjects.Borrower;
import com.coveros.training.domainobjects.Loan;
import com.coveros.training.domainobjects.User;
import org.apache.commons.lang3.builder.ToStringBuilder;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.postgresql.ds.PGSimpleDataSource;

import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;
import javax.sql.DataSource;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.sql.*;

public class PersistenceLayer {

    private static final Logger logger = LogManager.getLogger();

    private final DataSource dataSource;

    public PersistenceLayer() {
        this(obtainDataSource());
    }

    PersistenceLayer(DataSource ds) {
        dataSource = ds;
    }

    private static DataSource obtainDataSource() {
        try {
            // First, in the most common case, we try to get a datasource from context,
            // which is possibly mainly when running in a Servlet container.
            Context ctx = new InitialContext();
            return(DataSource) ctx.lookup("java:/comp/env/jdbc/demo");
        } catch (NamingException e) {
            // we'll likely get here if we couldn't find a name in the context - which is easily
            // possible if we're running tests, since in that case we're often not
            // running as a servlet with its accompanying context.
            logger.info("NamingException occurred, switching to direct Connection creation.  Exception: " + e);
            return getSimpleDataSource();
        }
    }

    /**
     * Get a simple {@link DataSource}, necessary when running
     * outside of a Servlet container.
     */
    private static DataSource getSimpleDataSource() {
        final PGSimpleDataSource ds = new PGSimpleDataSource();
        ds.setUser("postgres");
        ds.setPassword("postgres");
        ds.setUrl("jdbc:postgresql://localhost/training");
        return ds;
    }

    /**
     * This command provides a template to execute updates (including inserts) on the database
     * @param sqlData An object that contains the necessary components to run a SQL statement.
     *                Usually contains some SQL text and some values that will be injected
     *                into the statement at run-time.
     * @return the generated id of the new row of data.  Generated by the database.
     */
    long executeUpdateTemplate(SqlData sqlData) {
        try (Connection connection = dataSource.getConnection()) {
            try (PreparedStatement st = prepareStatementWithKeys(sqlData, connection)) {
                return executeUpdateOnPreparedStatement(sqlData, st);
            }
        } catch (SQLException ex) {
            throw new SqlRuntimeException(ex);
        }
    }

    long executeUpdateOnPreparedStatement(SqlData sqlData, PreparedStatement st) throws SQLException {
        sqlData.applyParametersToPreparedStatement(st);
        st.executeUpdate();
        try (ResultSet generatedKeys = st.getGeneratedKeys()) {
            long newId;
            if (generatedKeys.next()) {
                newId = generatedKeys.getLong(1);
                assert (newId > 0);
            } else {
                throw new SqlRuntimeException("failed INSERT.  SQL was " + sqlData.description + ": " + sqlData.preparedStatement);
            }
            return newId;
        }
    }

    /**
     * A helper method.  Simply creates a prepared statement that
     * always returns the generated keys from the database, like
     * when you insert a new row of data in a table with auto-generating primary key.
     * @param sqlData see {@link SqlData}
     * @param connection a typical {@link Connection}
     */
    private PreparedStatement prepareStatementWithKeys(SqlData sqlData, Connection connection) throws SQLException {
        return connection.prepareStatement(
                     sqlData.preparedStatement,
                     Statement.RETURN_GENERATED_KEYS);
    }

    /**
     * Creates a new borrower in the database
     * @param borrowerName the name of the borrower
     * @return a long id representing its id in the database.  Generated by the database.
     */
    long saveNewBorrower(String borrowerName) {
        final SqlData sqlData = new SqlData(
            "adds a new library borrower",
            "INSERT INTO library.borrower (name) VALUES (?);");
        sqlData.addParameter(borrowerName, String.class);

        return executeUpdateTemplate(sqlData);
    }

    /**
     * Creates a new loan of a book in the database.
     * @param book a book we have to loan out
     * @param borrower a person who is borrowing the book
     * @param borrowDate the date this book was borrowed
     * @return a long id representing its id in the database.  Generated by the database.
     */
    long createLoan(Book book, Borrower borrower, Date borrowDate) {
        final SqlData sqlData = new SqlData(
            "Creates a new loan of a book to a borrower",
            "INSERT INTO library.loan (book, borrower, borrow_date) VALUES (?, ?, ?);");
        sqlData.addParameter(book.id, Long.class);
        sqlData.addParameter(borrower.id, Long.class);
        sqlData.addParameter(borrowDate, Date.class);

        return executeUpdateTemplate(sqlData);
    }

    /**
     * Creates a new book in the database
     * @param bookTitle the String title of a book
     * @return a long id representing its id in the database.  Generated by the database.
     */
    long saveNewBook(String bookTitle) {
        final SqlData sqlData = new SqlData(
            "Creates a new book in the database",
            "INSERT INTO library.book (title) VALUES (?);");
        sqlData.addParameter(bookTitle, String.class);

        return executeUpdateTemplate(sqlData);
    }

    /**
     * Save a new user to the database
     * @param username a String name of a user
     * @return a long id representing its id in the database.  Generated by the database.
     */
    long saveNewUser(String username) {
        final SqlData sqlData = new SqlData(
            "Creates a new user in the database",
            "INSERT INTO auth.user (name) VALUES (?);");
        sqlData.addParameter(username, String.class);

        return executeUpdateTemplate(sqlData);
    }

    /**
     * If we already have a borrower, this command allows us to change
     * their values (except for their id)
     * @param id the id of a borrower (a constant)
     * @param borrowerName the name of a borrower, which we can change.
     */
    void updateBorrower(long id, String borrowerName) {
        CheckUtils.checkIntParamPositive(id);
        final SqlData sqlData = new SqlData(
            "Updates the borrower's data",
            "UPDATE library.borrower SET name = ? WHERE id = ?;");
        sqlData.addParameter(borrowerName, String.class);
        sqlData.addParameter(id, Long.class);
        executeUpdateTemplate(sqlData);
    }

    /**
     * Given the id for a borrower, this command returns their name.
     * @param id a borrower's id.
     * @return the borrower's name, or an empty string if not found
     */
    String getBorrowerName(int id) {
        CheckUtils.checkIntParamPositive(id);
        try (Connection connection = dataSource.getConnection()) {
            try (PreparedStatement st =
                     connection.prepareStatement(
                         "SELECT name FROM library.borrower WHERE id = ?;")) {
                st.setLong(1, id);
                try (ResultSet resultSet = st.executeQuery()) {
                    if (resultSet.next()) {
                        final String name = resultSet.getString(1);
                        return StringUtils.makeNotNullable(name);
                    } else {
                        return "";
                    }
                }
            }
        } catch (SQLException ex) {
            throw new SqlRuntimeException(ex);
        }
    }

    /**
     * Searches for a borrower by name.  Returns full details
     * if found.  return empty borrower data if not found.
     * @param borrowerName the name of a borrower
     * @return a valid borrower, or an empty borrower if not found
     */
    Borrower searchBorrowerDataByName(String borrowerName) {
        try (Connection connection = dataSource.getConnection()) {
            try (PreparedStatement st =
                     connection.prepareStatement(
                         "SELECT id, name FROM library.borrower WHERE name = ?;")) {
                st.setString(1, borrowerName);
                try (ResultSet resultSet = st.executeQuery()) {
                    if (resultSet.next()) {
                        long id = resultSet.getLong(1);
                        String name = StringUtils.makeNotNullable(resultSet.getString(2));
                        return new Borrower(id, name);
                    } else {
                        return Borrower.createEmpty();
                    }
                }
            }
        } catch (SQLException ex) {
            throw new SqlRuntimeException(ex);
        }
    }

    Book searchBooksByTitle(String bookTitle) {
        try (Connection connection = dataSource.getConnection()) {
            try (PreparedStatement st =
                     connection.prepareStatement(
                         "SELECT id FROM library.book WHERE title = ?;")) {
                st.setString(1, bookTitle);
                try (ResultSet resultSet = st.executeQuery()) {
                    if (resultSet.next()) {
                        long id = resultSet.getLong(1);
                        return new Book(id, bookTitle);
                    } else {
                        return Book.createEmpty();
                    }
                }
            }
        } catch (SQLException ex) {
            throw new SqlRuntimeException(ex);
        }
    }

    User searchForUserByName(String username) {
        try (Connection connection = dataSource.getConnection()) {
            try (PreparedStatement st =
                     connection.prepareStatement(
                         "SELECT id  FROM auth.user WHERE name = ?;")) {
                st.setString(1, username);
                try (ResultSet resultSet = st.executeQuery()) {
                    if (resultSet.next()) {
                        final long id = resultSet.getLong(1);
                        return new User(username, id);
                    } else {
                        return User.createEmpty();
                    }
                }
            }
        } catch (SQLException ex) {
            throw new SqlRuntimeException(ex);
        }
    }

    boolean areCredentialsValid(String username, String password) {
        try (Connection connection = dataSource.getConnection()) {
            try (PreparedStatement st =
                     connection.prepareStatement(
                         "SELECT id FROM auth.user WHERE name = ? AND password_hash = ?;")) {
                final String hexHash = createHashedValueFromPassword(password);
                st.setString(1, username);
                st.setString(2, hexHash);
                try (ResultSet resultSet = st.executeQuery()) {
                    if (resultSet.next()) {
                        final long id = resultSet.getLong(1);
                        assert (id > 0);
                        return true;
                    } else {
                        return false;
                    }
                }
            }
        } catch (SQLException ex) {
            throw new SqlRuntimeException(ex);
        }
    }

    void updateUserWithPassword(long id, String password) {
        CheckUtils.checkIntParamPositive(id);
        final SqlData sqlData = new SqlData(
            "Updates the user's password field with a new hash",
            "UPDATE auth.user SET password_hash = ? WHERE id = ?;");
        String hashedPassword = createHashedValueFromPassword(password);
        sqlData.addParameter(hashedPassword, String.class);
        sqlData.addParameter(id, Long.class);
        executeUpdateTemplate(sqlData);
    }

    private String createHashedValueFromPassword(String password) {
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] encodedhash = digest.digest(
                password.getBytes(StandardCharsets.UTF_8));
            return bytesToHex(encodedhash);
        } catch (NoSuchAlgorithmException e) {
            throw new SqlRuntimeException(e);
        }
    }

    Loan searchForLoan(Book book) {
        try (Connection connection = dataSource.getConnection()) {
            try (PreparedStatement st =
                     connection.prepareStatement(
                         "select loan.id, loan.borrow_date, loan.borrower, bor.name FROM library.loan loan JOIN library.borrower bor ON bor.id = loan.id WHERE loan.book = ?;")) {
                st.setLong(1, book.id);
                try (ResultSet resultSet = st.executeQuery()) {
                    if (resultSet.next()) {
                        final long loanId = resultSet.getLong(1);
                        final Date borrowDate = resultSet.getDate(2);
                        final long borrowerId = resultSet.getLong(3);
                        final String borrowerName = StringUtils.makeNotNullable(resultSet.getString(4));
                        final Date borrowDateNotNullable = borrowDate == null ? Date.valueOf("0000-01-01") : borrowDate;
                        return new Loan(book, new Borrower(borrowerId, borrowerName), loanId, borrowDateNotNullable);
                    } else {
                        return Loan.createEmpty();
                    }
                }
            }
        } catch (SQLException ex) {
            throw new SqlRuntimeException(ex);
        }
    }

    private static String bytesToHex(byte[] hash) {
        StringBuilder hexString = new StringBuilder();
        for (byte hash1 : hash) {
            String hex = Integer.toHexString(0xff & hash1);
            if (hex.length() == 1) hexString.append('0');
            hexString.append(hex);
        }
        return hexString.toString();
    }

    public static PersistenceLayer createEmpty() {
        return new PersistenceLayer(new EmptyDataSource());
    }

    public boolean isEmpty() {
        return this.dataSource.getClass().equals(EmptyDataSource.class);
    }

    public final String toString() {
        return ToStringBuilder.reflectionToString(this);
    }
}
